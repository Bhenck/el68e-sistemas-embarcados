###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.3.193/W32 for ARM         28/Mar/2019  17:38:25
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\repositories\sistemas-embarcados\lab-1\display\src\cfaf128x128x16.c
#    Command line =  
#        -f C:\Users\Marcelo\AppData\Local\Temp\EW6B86.tmp
#        (C:\repositories\sistemas-embarcados\lab-1\display\src\cfaf128x128x16.c
#        -D ewarm -D PART_TM4C1294NCPDT -lcN
#        C:\repositories\sistemas-embarcados\lab-1\display\Debug\List -o
#        C:\repositories\sistemas-embarcados\lab-1\display\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\repositories\sistemas-embarcados\lab-1\display\..\..\..\ -I
#        C:\repositories\sistemas-embarcados\lab-1\display\..\ -I
#        C:\repositories\sistemas-embarcados\lab-1\display\..\inc\ -I
#        C:\repositories\sistemas-embarcados\lab-1\display\..\driverlib\ -Ol -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\repositories\sistemas-embarcados\lab-1\display\Debug\List\cfaf128x128x16.lst
#    Object file  =  
#        C:\repositories\sistemas-embarcados\lab-1\display\Debug\Obj\cfaf128x128x16.o
#
###############################################################################

C:\repositories\sistemas-embarcados\lab-1\display\src\cfaf128x128x16.c
      1          //..............................................................................
      2          //
      3          // Copyright (c) 2017 
      4          // Allan Patrick de Souza - <allansouza@alunos.utfpr.edu.br>
      5          // Guilherme Jacichen     - <jacichen@alunos.utfpr.edu.br>
      6          // Jessica Isoton Sampaio - <jessicasampaio@alunos.utfpr.edu.br>
      7          // Mariana Carrião        - <mcarriao@alunos.utfpr.edu.br>
      8          //
      9          // cfaf128x128x16.c - Display driver for the Crystalfontz CFAF128128B-0145T
     10          // display with an ST7735S.  This version uses an SSI interface to the display
     11          // controller. This driver was made to be used with the TivaWare grlib driver
     12          // set (ti.com/tivaware), and was based on the Kentec320x240x16_ssd2119_spi
     13          // driver for the ek-tm4c1294xl board, the cfal96x64x16 driver for the
     14          // dk-tm4c123g board and the Energia's Screen_HX8353E driver for dk-tm4c1294xl
     15          // board.
     16          //
     17          // All rights reserved. 
     18          // Software License Agreement
     19          //...............................................................................
     20          
     21          //*****************************************************************************
     22          //
     23          //! \addtogroup display_api
     24          //! @{
     25          //
     26          //*****************************************************************************
     27          
     28          #include <stdbool.h>
     29          #include <stdint.h>
     30          #include "inc/hw_memmap.h"
     31          #include "inc/hw_ssi.h"
     32          #include "inc/hw_types.h"
     33          #include "inc/hw_sysctl.h"
     34          #include "driverlib/gpio.h"
     35          #include "driverlib/ssi.h"
     36          #include "driverlib/sysctl.h"
     37          #include "driverlib/rom.h"
     38          #include "driverlib/pin_map.h"
     39          #include "grlib/grlib.h"
     40          
     41          #include "system_tm4c1294ncpdt.h" // CMSIS-Core
     42          
     43          #define DISPLAY_WIDTH  128
     44          #define DISPLAY_HEIGHT 128
     45          
     46          // ST7735 LCD controller Command Set
     47          #define CM_NOP             0x00
     48          #define CM_SWRESET         0x01
     49          #define CM_RDDID           0x04
     50          #define CM_RDDST           0x09
     51          #define CM_SLPIN           0x10
     52          #define CM_SLPOUT          0x11
     53          #define CM_PTLON           0x12
     54          #define CM_NORON           0x13
     55          #define CM_INVOFF          0x20
     56          #define CM_INVON           0x21
     57          #define CM_GAMSET          0x26
     58          #define CM_DISPOFF         0x28
     59          #define CM_DISPON          0x29
     60          #define CM_CASET           0x2A
     61          #define CM_RASET           0x2B
     62          #define CM_RAMWR           0x2C
     63          #define CM_RGBSET          0x2D
     64          #define CM_RAMRD           0x2E
     65          #define CM_PTLAR           0x30
     66          #define CM_MADCTL          0x36
     67          #define CM_COLMOD          0x3A
     68          #define CM_SETPWCTR        0xB1
     69          #define CM_SETDISPL        0xB2
     70          #define CM_FRMCTR3         0xB3
     71          #define CM_SETCYC          0xB4
     72          #define CM_SETBGP          0xb5
     73          #define CM_SETVCOM         0xB6
     74          #define CM_SETSTBA         0xC0
     75          #define CM_SETID           0xC3
     76          #define CM_GETHID          0xd0
     77          #define CM_SETGAMMA        0xE0
     78          #define CM_MADCTL_MY       0x80
     79          #define CM_MADCTL_MX       0x40
     80          #define CM_MADCTL_MV       0x20
     81          #define CM_MADCTL_ML       0x10
     82          #define CM_MADCTL_RGB      0x08
     83          #define CM_MADCTL_MH       0x04
     84          
     85          //Colors
     86          const uint16_t blackColor    = 0x0000;
     87          const uint16_t whiteColor    = 0xFFFF;
     88          const uint16_t redColor      = 0xF800;
     89          const uint16_t greenColor    = 0x07E0;
     90          const uint16_t blueColor     = 0x001F;
     91          const uint16_t yellowColor   = 0xFFE0;
     92          const uint16_t cyanColor     = 0x07FF;
     93          const uint16_t orangeColor   = 0xFBE0;
     94          const uint16_t magentaColor  = 0xF80F;
     95          const uint16_t violetColor   = 0xF81F;
     96          const uint16_t grayColor     = 0x7BEF;
     97          const uint16_t darkGrayColor = 0x39E7;
     98          
     99          //Abstract for delay calls
    100          #define delay(d) SysCtlDelay(d*10)
    101          
    102          //*****************************************************************************
    103          //
    104          // Defines the SSI and GPIO peripherals that are used for this display.
    105          //
    106          //*****************************************************************************
    107          #define DISPLAY_SSI_PERIPH          SYSCTL_PERIPH_SSI2
    108          #define DISPLAY_SSI_GPIO_PERIPH     SYSCTL_PERIPH_GPIOD
    109          #define DISPLAY_RST_GPIO_PERIPH     SYSCTL_PERIPH_GPIOH
    110          #define DISPLAY_C_D_GPIO_PERIPH     SYSCTL_PERIPH_GPIOL
    111          #define DISPLAY_CS_GPIO_PERIPH      SYSCTL_PERIPH_GPION
    112          
    113          //*****************************************************************************
    114          //
    115          // Defines the GPIO pin configuration macros for the pins that are used for
    116          // the SSI function.
    117          //
    118          //*****************************************************************************
    119          #define DISPLAY_PINCFG_SSICLK       GPIO_PD3_SSI2CLK
    120          #define DISPLAY_PINCFG_SSIFSS       GPIO_PD2_SSI2FSS
    121          #define DISPLAY_PINCFG_SSITX        GPIO_PD1_SSI2XDAT0
    122          #define DISPLAY_PINCFG_SSIRX        GPIO_PD0_SSI2XDAT1
    123          
    124          //*****************************************************************************
    125          //
    126          // Defines the port and pins for the SSI peripheral.
    127          //
    128          //*****************************************************************************
    129          #define DISPLAY_SSI_PORT            GPIO_PORTD_BASE
    130          #define DISPLAY_SSI_PIN_CLK         GPIO_PIN_3
    131          #define DISPLAY_SSI_PIN_FSS         GPIO_PIN_2
    132          #define DISPLAY_SSI_PIN_TX          GPIO_PIN_1
    133          #define DISPLAY_SSI_PIN_RX          GPIO_PIN_0
    134          #define DISPLAY_SSI_PINS            (DISPLAY_SSI_PIN_CLK | DISPLAY_SSI_PIN_FSS | DISPLAY_SSI_PIN_TX | DISPLAY_SSI_PIN_RX)
    135          
    136          //*****************************************************************************
    137          //
    138          // Defines the port and pins for the display voltage enable signal.
    139          //
    140          //*****************************************************************************
    141          //#define DISPLAY_ENV_PORT            GPIO_PORTG_BASE
    142          //#define DISPLAY_ENV_PIN             GPIO_PIN_0
    143          
    144          //*****************************************************************************
    145          //
    146          // Defines the port and pins for the display reset signal.
    147          //
    148          //*****************************************************************************
    149          #define DISPLAY_RST_PORT            GPIO_PORTH_BASE
    150          #define DISPLAY_RST_PIN             GPIO_PIN_3
    151          
    152          //*****************************************************************************
    153          //
    154          // Defines the port and pins for the display Data/Command (D/C) signal.
    155          //
    156          //*****************************************************************************
    157          #define DISPLAY_D_C_PORT            GPIO_PORTL_BASE
    158          #define DISPLAY_D_C_PIN	            GPIO_PIN_3
    159          
    160          //*****************************************************************************
    161          //
    162          // Defines the port and pins for the chip select (CS) signal.
    163          //
    164          //*****************************************************************************
    165          #define DISPLAY_CS_PORT             GPIO_PORTN_BASE
    166          #define DISPLAY_CS_PIN	            GPIO_PIN_2
    167          
    168          //*****************************************************************************
    169          //
    170          // Defines the SSI peripheral used and the data speed.
    171          //
    172          //*****************************************************************************
    173          #define DISPLAY_SSI_BASE            SSI2_BASE // SSI2
    174          #define DISPLAY_SSI_CLOCK           12000000 // 12MHz
    175          
    176          static uint32_t g_ui32SysClock;
    177          static uint8_t _orientation;
    178          
    179          //*****************************************************************************
    180          //
    181          // Translates a 24-bit RGB color to a display driver-specific color.
    182          //
    183          // \param c is the 24-bit RGB color.  The least-significant byte is the blue
    184          // channel, the next byte is the green channel, and the third byte is the red
    185          // channel.
    186          //
    187          // This macro translates a 24-bit RGB color into a value that can be written
    188          // into the display's frame buffer in order to reproduce that color, or the
    189          // closest possible approximation of that color.
    190          //
    191          // \return Returns the display-driver specific color.
    192          //
    193          // 24-bit format: XXXX XXXX RRRR RRRR GGGG GGGG BBBB BBBB
    194          // 18-bit format: ---- ---- ---- XXRR RRRR GGGG GGBB BBBB
    195          // 16-bit format: ---- ---- ---- ---- RRRR RGGG GGGB BBBB
    196          //  8-bit format: ---- ---- ---- ---- ---- ---- RRRG GGBB
    197          //
    198          //
    199          //*****************************************************************************
    200          #define DPYCOLORTRANSLATE18(c)  ((((c) & 0x00fc0000) >> 6) |                  \
    201                                           (((c) & 0x0000fc00) >> 4) |                  \
    202                                           (((c) & 0x000000fc) >> 2))
    203          #define DPYCOLORTRANSLATE16(c)  ((((c) & 0x00f80000) >> 8) |                  \
    204                                           (((c) & 0x0000fc00) >> 5) |                  \
    205                                           (((c) & 0x000000f8) >> 3))
    206          #define DPYCOLORTRANSLATE8(c)   ((((c) & 0x00e00000) >> 16) |                 \
    207                                           (((c) & 0x0000e000) >> 11) |                 \
    208                                           (((c) & 0x000000c0) >> 6))
    209          #define DPYCOLORTRANSLATE DPYCOLORTRANSLATE16
    210          
    211          //Swap contents of 2 uint16 variables
    212          static void 
    213          swap_ui16(uint16_t* a, uint16_t* b){
    214          	uint16_t aux = *a;
    215          	*a = *b;
    216          	*b = aux;
    217          }
    218          
    219          //Swap contents of 2 uint32 variables
    220          static void 
    221          swap_i32(int32_t* a, int32_t* b){
    222          	int32_t aux = *a;
    223          	*a = *b;
    224          	*b = aux;
    225          }
    226          
    227          //Transfer data by the configured SSI (send and receive)
    228          static uint8_t 
    229          cfaf128x128x16SsiTransfer(uint8_t command8){
    230          	uint32_t received32;
    231          	SSIDataPut(DISPLAY_SSI_BASE, command8);
    232          	while(SSIBusy(DISPLAY_SSI_BASE));
    233          	SSIDataGet(DISPLAY_SSI_BASE, &received32);
    234          	return (uint8_t) received32;
    235          }
    236          
    237          //*****************************************************************************
    238          //
    239          //! Write a set of command bytes to the display controller.
    240          //
    241          //! \param command8 is a command byte.
    242          //!
    243          //! This function provides a way to send command bytes to the display
    244          //! controller.  It can be used for single commands. It will wait for any previous operation to
    245          //! finish, and then copy all the command bytes to the controller.  It will
    246          //! not return until the last command byte has been written to the SSI FIFO,
    247          //! but data could still be shifting out to the display controller when this
    248          //! function returns.
    249          //!
    250          //! \return None.
    251          //
    252          //*****************************************************************************
    253          static void
    254          cfaf128x128x16WriteCommand(uint8_t command8){		
    255          		GPIOPinWrite(DISPLAY_D_C_PORT, DISPLAY_D_C_PIN, 0);
    256          		GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, 0);
    257          		cfaf128x128x16SsiTransfer(command8);
    258          		GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, DISPLAY_CS_PIN);
    259          }
    260          
    261          //*****************************************************************************
    262          //
    263          //! Write a set of data bytes to the display controller.
    264          //
    265          //! \param data8 is a pointer to a set of data bytes, containing pixel data.
    266          //! \param ndata is the count of command bytes.
    267          //!
    268          //! This function provides a way to send a set of pixel data to the display.
    269          //! The data will draw pixels according to whatever the most recent col, row
    270          //! settings are for the display.  It will wait for any previous operation to
    271          //! finish, and then copy all the data bytes to the controller.  It will
    272          //! not return until the last data byte has been written to the SSI FIFO,
    273          //! but data could still be shifting out to the display controller when this
    274          //! function returns.
    275          //!
    276          //! \return None.
    277          //
    278          //*****************************************************************************
    279          static void
    280          cfaf128x128x16WriteData(const uint8_t *data8, uint32_t ndata){		
    281          	GPIOPinWrite(DISPLAY_D_C_PORT, DISPLAY_D_C_PIN, DISPLAY_D_C_PIN);
    282          	GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, 0);
    283          	for(;ndata--;data8++)
    284          		cfaf128x128x16SsiTransfer(*data8);
    285          	GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, DISPLAY_CS_PIN);
    286          }
    287          
    288          //Write a command and one data byte
    289          static void 
    290          cfaf128x128x16WriteRegister(uint8_t command8, uint8_t data8){
    291          	cfaf128x128x16WriteCommand(command8);
    292          	cfaf128x128x16WriteData(&data8, 1);
    293          }
    294          
    295          //Setup drawing window. Data sent to the display will fill the pixels of 
    296          //the starting coordinate acording to the orientation set.
    297          static void 
    298          cfaf128x128x16SetWindow(uint16_t x0, uint16_t x1, uint16_t y0, uint16_t y1){
    299          	uint8_t bytes16[2];
    300          	
    301          	switch (_orientation) {
    302          		case 0:
    303          			x0 += 2;
    304          			y0 += 3;
    305          			x1 += 2;
    306          			y1 += 3;
    307          			break;
    308          		case 1:
    309          			x0 += 3;
    310          			y0 += 2;
    311          			x1 += 3;
    312          			y1 += 2;
    313          			break;
    314          		case 2:
    315          			x0 += 2;
    316          			y0 += 1;
    317          			x1 += 2;
    318          			y1 += 1;
    319          			break;
    320          		case 3:
    321          			x0 += 1;
    322          			y0 += 2;
    323          			x1 += 1;
    324          			y1 += 2;
    325          			break;
    326          		default:
    327          			break;
    328          	}
    329          	//Setup columns
    330          	cfaf128x128x16WriteCommand(CM_CASET);
    331          	bytes16[0] = (x0&0xFF00)>>8;
    332          	bytes16[1] =  x0&0xFF;
    333          	cfaf128x128x16WriteData(bytes16, 2);
    334          	bytes16[0] = (x1&0xFF00)>>8;
    335          	bytes16[1] =  x1&0xFF;
    336          	cfaf128x128x16WriteData(bytes16, 2);
    337          
    338          	//Setup rows
    339          	cfaf128x128x16WriteCommand(CM_RASET);
    340          	bytes16[0] = (y0&0xFF00)>>8;
    341          	bytes16[1] =  y0&0xFF;
    342          	cfaf128x128x16WriteData(bytes16, 2);
    343          	bytes16[0] = (y1&0xFF00)>>8;
    344          	bytes16[1] =  y1&0xFF;
    345          	cfaf128x128x16WriteData(bytes16, 2);
    346          	
    347          	//Prepare to write to the display pixel matrix
    348          	cfaf128x128x16WriteCommand(CM_RAMWR);
    349          }
    350          
    351          //Draws a rectangles with the given limits and color
    352          void 
    353          cfaf128x128x16Rect(uint16_t x0, uint16_t x1, uint16_t y0, uint16_t y1, uint32_t color){
    354          	uint32_t t;	
    355          	uint32_t hor_size;
    356          	uint32_t ver_size;
    357          	uint8_t	lowByte =   0x00FF & color;
    358          	uint8_t	highByte = (0xFF00 & color)>>8;
    359          
    360          	hor_size = x1 - x0 + 1;
    361          	ver_size = y1 - y0 + 1;
    362          		
    363          	cfaf128x128x16SetWindow(x0, x1, y0, y1);
    364          	
    365                  GPIOPinWrite(DISPLAY_D_C_PORT, DISPLAY_D_C_PIN, DISPLAY_D_C_PIN);
    366                  GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, 0);
    367          	for(t = (uint32_t) hor_size*ver_size; t>0; t--){
    368          		cfaf128x128x16SsiTransfer(highByte);
    369          		cfaf128x128x16SsiTransfer(lowByte);
    370          	}
    371          	GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, DISPLAY_CS_PIN);
    372          }
    373          
    374          //Draws a vertical line with the given limits and color
    375          void 
    376          cfaf128x128x16LineVer(uint16_t x, uint16_t y0, uint16_t y1, uint16_t thickness, uint32_t color){
    377          	cfaf128x128x16Rect(x, x+thickness, y0, y1, color);
    378          }
    379          
    380          //Draws a horizontal line with the given limits and color
    381          void 
    382          cfaf128x128x16LineHor(uint16_t x0, uint16_t x1, uint16_t y, uint16_t thickness, uint32_t color){
    383          	cfaf128x128x16Rect(x0, x1, y, y+thickness, color);
    384          }
    385          
    386          //Draws a dot with the given coordinator and color
    387          void
    388          cfaf128x128x16Dot(uint16_t x, uint16_t y, uint16_t thickness, uint32_t color){
    389          	cfaf128x128x16Rect(x, x+thickness, y, y+thickness, color);
    390          }
    391          
    392          //*****************************************************************************
    393          //
    394          //! Draws a pixel on the screen.
    395          //!
    396          //! \param pvDisplayData is a pointer to the driver-specific data for this
    397          //! display driver.
    398          //! \param i32X is the X coordinate of the pixel.
    399          //! \param i32Y is the Y coordinate of the pixel.
    400          //! \param ui32Value is the color of the pixel.
    401          //!
    402          //! This function sets the given pixel to a particular color.  The coordinates
    403          //! of the pixel are assumed to be within the extents of the display.
    404          //!
    405          //! \return None.
    406          //
    407          //*****************************************************************************
    408          static void
    409          cfaf128x128x16PixelDraw(void *pvDisplayData, int32_t i32X, int32_t i32Y,
    410                                uint32_t ui32Value)
    411          {
    412          	cfaf128x128x16Dot(i32X, i32Y, 0, ui32Value);
    413          }
    414          
    415          //*****************************************************************************
    416          //
    417          //! Draws a horizontal sequence of pixels on the screen.
    418          //!
    419          //! \param pvDisplayData is a pointer to the driver-specific data for this
    420          //! display driver.
    421          //! \param i32X is the X coordinate of the first pixel.
    422          //! \param i32Y is the Y coordinate of the first pixel.
    423          //! \param i32X0 is sub-pixel offset within the pixel data, which is valid for 1
    424          //! or 4 bit per pixel formats.
    425          //! \param i32Count is the number of pixels to draw.
    426          //! \param i32BPP is the number of bits per pixel; must be 1, 4, or 8 optionally
    427          //! ORed with various flags unused by this driver.
    428          //! \param pui8Data is a pointer to the pixel data.  For 1 and 4 bit per pixel
    429          //! formats, the most significant bit(s) represent the left-most pixel.
    430          //! \param pui8Palette is a pointer to the palette used to draw the pixels.
    431          //!
    432          //! This function draws a horizontal sequence of pixels on the screen, using
    433          //! the supplied palette.  For 1 bit per pixel format, the palette contains
    434          //! pre-translated colors; for 4 and 8 bit per pixel formats, the palette
    435          //! contains 24-bit RGB values that must be translated before being written to
    436          //! the display.
    437          //!
    438          //! \return None.
    439          //
    440          //*****************************************************************************
    441          static void
    442          cfaf128x128x16PixelDrawMultiple(void *pvDisplayData, int32_t i32X, int32_t i32Y,
    443                                        int32_t i32X0, int32_t i32Count, int32_t i32BPP,
    444                                        const uint8_t *pui8Data,
    445                                        const uint8_t *pui8Palette)
    446          {
    447          	uint8_t	lowByte, highByte;
    448          	uint32_t ui32Byte, color;
    449          	cfaf128x128x16SetWindow(i32X, i32X + i32Count, i32Y, i32Y);
    450          
    451          	GPIOPinWrite(DISPLAY_D_C_PORT, DISPLAY_D_C_PIN, DISPLAY_D_C_PIN);
    452          	GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, 0);
    453          	
    454          	// Determine how to interpret the pixel data based on the number of bits
    455          	// per pixel.
    456          	switch(i32BPP & ~GRLIB_DRIVER_FLAG_NEW_IMAGE) {
    457          		// The pixel data is in 1 bit per pixel format.
    458          		case 1:
    459          			// Loop while there are more pixels to draw.
    460          			while(i32Count){
    461          				ui32Byte = *pui8Data++;
    462          				// Loop through the pixels in this byte of image data.
    463          				for(; (i32X0 < 8) && i32Count; i32X0++, i32Count--) {
    464          					// Get the next byte of image data.
    465          					color = ((uint32_t *)pui8Palette) [(ui32Byte >> (7 - i32X0)) & 1];
    466          					// Draw this pixel in the appropriate color.
    467          					lowByte =   0x00FF & color;
    468          					highByte = (0xFF00 & color)>>8;
    469          					cfaf128x128x16SsiTransfer(highByte);
    470          					cfaf128x128x16SsiTransfer(lowByte);
    471          				}
    472          				// Start at the beginning of the next byte of image data.
    473          				i32X0 = 0;
    474          			}
    475          			// The image data has been drawn.
    476          			break;
    477          		// The pixel data is in 4 bit per pixel format.
    478          		case 4:
    479          			// Loop while there are more pixels to draw.  "Duff's device" is
    480          			// used to jump into the middle of the loop if the first nibble of
    481          			// the pixel data should not be used.  Duff's device makes use of
    482          			// the fact that a case statement is legal anywhere within a
    483          			// sub-block of a switch statement.  See
    484          			// http://en.wikipedia.org/wiki/Duff's_device for detailed
    485          			// information about Duff's device.
    486          			switch(i32X0 & 1){
    487          				case 0:
    488          					while(i32Count){
    489          						// Get the upper nibble of the next byte of pixel data
    490          						// and extract the corresponding entry from the
    491          						// palette.
    492          						ui32Byte = (*pui8Data >> 4) * 3;
    493          						ui32Byte = (*(uint32_t *)(pui8Palette + ui32Byte) &
    494          											0x00ffffff);
    495          						// Translate this palette entry and write it to the
    496          						// screen.
    497          						color = DPYCOLORTRANSLATE(ui32Byte);
    498          						lowByte =   0x00FF & color;
    499          						highByte = (0xFF00 & color)>>8;
    500          						cfaf128x128x16SsiTransfer(highByte);
    501          						cfaf128x128x16SsiTransfer(lowByte);
    502          						// Decrement the count of pixels to draw.
    503          						i32Count--;
    504          						// See if there is another pixel to draw.
    505          						if(i32Count) {
    506          				case 1:
    507          							// Get the lower nibble of the next byte of pixel
    508          							// data and extract the corresponding entry from
    509          							// the palette.
    510          							ui32Byte = (*pui8Data++ & 15) * 3;
    511          							ui32Byte = (*(uint32_t *)(pui8Palette + ui32Byte) &
    512          											0x00ffffff);
    513          							// Translate this palette entry and write it to the
    514          							// screen.
    515          							color = DPYCOLORTRANSLATE(ui32Byte);
    516          							lowByte =   0x00FF & color;
    517          							highByte = (0xFF00 & color)>>8;
    518          							cfaf128x128x16SsiTransfer(highByte);
    519          							cfaf128x128x16SsiTransfer(lowByte);
    520          							// Decrement the count of pixels to draw.
    521          							i32Count--;
    522          						}
    523          					}
    524          			}
    525          			// The image data has been drawn.
    526          			break;
    527          		// The pixel data is in 8 bit per pixel format.
    528          		case 8:
    529          			while(i32Count--) {
    530          				// Get the next byte of pixel data and extract the
    531          				// corresponding entry from the palette.				
    532          				ui32Byte = *pui8Data++ * 3;
    533          				ui32Byte = *(uint32_t *)(pui8Palette + ui32Byte) & 0x00ffffff;
    534          				// Translate this palette entry and write it to the screen.
    535          				color = DPYCOLORTRANSLATE(ui32Byte);
    536          				lowByte =   0x00FF & color;
    537          				highByte = (0xFF00 & color)>>8;
    538          				cfaf128x128x16SsiTransfer(highByte);
    539          				cfaf128x128x16SsiTransfer(lowByte);
    540          			}
    541          			// The image data has been drawn.
    542          			break;
    543          		// We are being passed data in the display's native format.  Merely
    544          		// write it directly to the display.  This is a special case which is
    545          		// not used by the graphics library but which is helpful to
    546          		// applications which may want to handle, for example, JPEG images.
    547          		case 16:
    548          			// Loop while there are more pixels to draw.
    549          			while(i32Count--) {
    550          				// Get the next byte of pixel data and extract the
    551          				// corresponding entry from the palette.
    552          				ui32Byte = *((uint16_t*) pui8Data);
    553          				pui8Data += 2;
    554          				// Translate this palette entry and write it to the screen.
    555          				lowByte =   0x00FF & ui32Byte;
    556          				highByte = (0xFF00 & ui32Byte)>>8;
    557          				cfaf128x128x16SsiTransfer(highByte);
    558          				cfaf128x128x16SsiTransfer(lowByte);
    559          			}
    560          			// The image data has been drawn.
    561          			break;
    562          	}
    563          	GPIOPinWrite(DISPLAY_CS_PORT, DISPLAY_CS_PIN, DISPLAY_CS_PIN);
    564          }
    565          
    566          //*****************************************************************************
    567          //
    568          //! Draws a horizontal line.
    569          //!
    570          //! \param pvDisplayData is a pointer to the driver-specific data for this
    571          //! display driver.
    572          //! \param i32X1 is the X coordinate of the start of the line.
    573          //! \param i32X2 is the X coordinate of the end of the line.
    574          //! \param i32Y is the Y coordinate of the line.
    575          //! \param ui32Value is the color of the line.
    576          //!
    577          //! This function draws a horizontal line on the display.  The coordinates of
    578          //! the line are assumed to be within the extents of the display.
    579          //!
    580          //! \return None.
    581          //
    582          //*****************************************************************************
    583          static void
    584          cfaf128x128x16LineDrawH(void *pvDisplayData, int32_t i32X1, int32_t i32X2, int32_t i32Y,
    585                                uint32_t ui32Value)
    586          {
    587          	if(i32X1 > i32X2) swap_i32(&i32X1, &i32X2);
    588          	cfaf128x128x16LineHor(i32X1, i32X2, i32Y, 0, ui32Value);
    589          }
    590          
    591          //*****************************************************************************
    592          //
    593          //! Draws a vertical line.
    594          //!
    595          //! \param pvDisplayData is a pointer to the driver-specific data for this
    596          //! display driver.
    597          //! \param i32X is the X coordinate of the line.
    598          //! \param i32Y1 is the Y coordinate of the start of the line.
    599          //! \param i32Y2 is the Y coordinate of the end of the line.
    600          //! \param ui32Value is the color of the line.
    601          //!
    602          //! This function draws a vertical line on the display.  The coordinates of the
    603          //! line are assumed to be within the extents of the display.
    604          //!
    605          //! \return None.
    606          //
    607          //*****************************************************************************
    608          static void
    609          cfaf128x128x16LineDrawV(void *pvDisplayData, int32_t i32X, int32_t i32Y1, int32_t i32Y2,
    610                                uint32_t ui32Value)
    611          {
    612          	if(i32Y1 > i32Y2) swap_i32(&i32Y1, &i32Y2);
    613          	cfaf128x128x16LineVer(i32X, i32Y1, i32Y2, 0, ui32Value);
    614          }
    615          
    616          //*****************************************************************************
    617          //
    618          //! Fills a rectangle.
    619          //!
    620          //! \param pvDisplayData is a pointer to the driver-specific data for this
    621          //! display driver.
    622          //! \param pRect is a pointer to the structure describing the rectangle.
    623          //! \param ui32Value is the color of the rectangle.
    624          //!
    625          //! This function fills a rectangle on the display.  The coordinates of the
    626          //! rectangle are assumed to be within the extents of the display, and the
    627          //! rectangle specification is fully inclusive (in other words, both i16XMin and
    628          //! i16XMax are drawn, aint32_t with i16YMin and i16YMax).
    629          //!
    630          //! \return None.
    631          //
    632          //*****************************************************************************
    633          static void
    634          cfaf128x128x16RectFill(void *pvDisplayData, const tRectangle *pRect,
    635                               uint32_t ui32Value)
    636          {
    637          	uint16_t x0 = pRect->i16XMin;
    638          	uint16_t x1 = pRect->i16XMax;
    639          	uint16_t y0 = pRect->i16YMin;
    640          	uint16_t y1 = pRect->i16YMax;
    641          	
    642          	if(x0 > x1) swap_ui16(&x0, &x1);
    643          	if(y0 > y1) swap_ui16(&y0, &y1);
    644          	cfaf128x128x16Rect(x0, x1, y0, y1, ui32Value);
    645          }
    646          
    647          //*****************************************************************************
    648          //
    649          //! Translates a 24-bit RGB color to a display driver-specific color.
    650          //!
    651          //! \param pvDisplayData is a pointer to the driver-specific data for this
    652          //! display driver.
    653          //! \param ui32Value is the 24-bit RGB color.  The least-significant byte is the
    654          //! blue channel, the next byte is the green channel, and the third byte is the
    655          //! red channel.
    656          //!
    657          //! This function translates a 24-bit RGB color into a value that can be
    658          //! written into the display's frame buffer in order to reproduce that color,
    659          //! or the closest possible approximation of that color.
    660          //!
    661          //! \return Returns the display-driver specific color.
    662          //
    663          //*****************************************************************************
    664          static uint32_t
    665          cfaf128x128x16ColorTranslate(void *pvDisplayData, uint32_t ui32Value)
    666          {
    667              // Translate from a 24-bit RGB color to a 3-3-2 RGB color.
    668              return(DPYCOLORTRANSLATE(ui32Value));
    669          }
    670          
    671          //*****************************************************************************
    672          //
    673          //! Flushes any cached drawing operations.
    674          //!
    675          //! \param pvDisplayData is a pointer to the driver-specific data for this
    676          //! display driver.
    677          //!
    678          //! This functions flushes any cached drawing operations to the display.  This
    679          //! is useful when a local frame buffer is used for drawing operations, and the
    680          //! flush would copy the local frame buffer to the display.  Since no memory
    681          //! based frame buffer is used for this driver, the flush is a no operation.
    682          //!
    683          //! \return None.
    684          //
    685          //*****************************************************************************
    686          static void
    687          cfaf128x128x16Flush(void *pvDisplayData)
    688          {
    689              //
    690              // There is nothing to be done.
    691              //
    692          }
    693          
    694          //*****************************************************************************
    695          //
    696          //! The display structure that describes the driver for the Crystalfontz
    697          //! CFAF128128B-0145T panel with ST7735 controller.
    698          //
    699          //*****************************************************************************
    700          const tDisplay g_sCfaf128x128x16 =
    701          {
    702              sizeof(tDisplay),
    703              0,
    704              DISPLAY_WIDTH,
    705              DISPLAY_HEIGHT,
    706              cfaf128x128x16PixelDraw,
    707              cfaf128x128x16PixelDrawMultiple,
    708              cfaf128x128x16LineDrawH,
    709              cfaf128x128x16LineDrawV,
    710              cfaf128x128x16RectFill,
    711              cfaf128x128x16ColorTranslate,
    712              cfaf128x128x16Flush
    713          };
    714          
    715          //Set the orientation for the rect filling
    716          void 
    717          cfaf128x128x16SetOrientation(uint8_t orientation){
    718          	uint8_t data = 0;
    719          	
    720          	_orientation = orientation & 0x11; //%4	
    721          	
    722          	cfaf128x128x16WriteCommand(CM_MADCTL);
    723          	switch (orientation){
    724          		case 0:
    725          			data = CM_MADCTL_MX | CM_MADCTL_MY | CM_MADCTL_RGB;
    726          			break;
    727          		case 1:
    728          			data = CM_MADCTL_MY | CM_MADCTL_MV | CM_MADCTL_RGB;
    729          			break;
    730          		case 2:
    731          			data = CM_MADCTL_RGB;
    732          			break;
    733          		case 3:
    734          			data = CM_MADCTL_MX | CM_MADCTL_MV | CM_MADCTL_RGB;
    735          			break;
    736          	}
    737          	cfaf128x128x16WriteData(&data, 1);
    738          }
    739          
    740          //Clear screen with solid color
    741          void 
    742          cfaf128x128x16ClearColor(uint16_t color) {
    743          	uint8_t lastOrientation = _orientation;
    744          	
    745          	cfaf128x128x16SetOrientation(0);
    746          	cfaf128x128x16Rect(0, DISPLAY_WIDTH-1, 0, DISPLAY_HEIGHT-1, color);
    747          	cfaf128x128x16SetOrientation(lastOrientation);
    748          }
    749          
    750          //Clear screen with black color
    751          void
    752          cfaf128x128x16Clear(){
    753          	cfaf128x128x16ClearColor(blackColor);
    754          }
    755          
    756          //Set SSI data mode
    757          static void 
    758          ssiSetDataMode(uint8_t mode) {
    759          	HWREG(DISPLAY_SSI_BASE + SSI_O_CR0) &= ~(SSI_CR0_SPO | SSI_CR0_SPH);
    760          	HWREG(DISPLAY_SSI_BASE + SSI_O_CR0) |= mode;
    761          }
    762          
    763          //Set SSI clock divider
    764          static void
    765          ssiSetClockDivider(uint8_t divider){
    766            //value must be even
    767            HWREG(DISPLAY_SSI_BASE + SSI_O_CPSR) = divider;
    768          }
    769          
    770          //Initialiaze SSI comunication configuration
    771          void
    772          InitSSICom(void){
    773          	uint32_t initialData = 0;
    774          	g_ui32SysClock = SystemCoreClock; // __SysCtlClockGet();
    775          	
    776          	// Enable the peripherals used by this driver
    777          	SysCtlPeripheralEnable(DISPLAY_SSI_PERIPH);
    778          	SysCtlPeripheralEnable(DISPLAY_SSI_GPIO_PERIPH);
    779          
    780          	GPIOPinConfigure(DISPLAY_PINCFG_SSICLK);
    781          	GPIOPinConfigure(DISPLAY_PINCFG_SSIFSS);
    782          	GPIOPinConfigure(DISPLAY_PINCFG_SSITX);
    783          	GPIOPinConfigure(DISPLAY_PINCFG_SSIRX);
    784          	
    785          	GPIOPinTypeSSI(DISPLAY_SSI_PORT, DISPLAY_SSI_PINS);
    786          	
    787          	SSIClockSourceSet(DISPLAY_SSI_BASE, SSI_CLOCK_PIOSC);
    788          	SSIConfigSetExpClk(DISPLAY_SSI_BASE, g_ui32SysClock, 
    789          		SSI_FRF_MOTO_MODE_0, SSI_MODE_MASTER, DISPLAY_SSI_CLOCK, 8);
    790          
    791          	SSIEnable(DISPLAY_SSI_BASE);
    792          	while(SSIDataGetNonBlocking(DISPLAY_SSI_BASE, &initialData));
    793          }
    794          
    795          //*****************************************************************************
    796          //
    797          //! Initializes the display driver.
    798          //!
    799          //! This function initializes the ST7735S display controller on the panel,
    800          //! preparing it to display data.
    801          //!
    802          //! \return None.
    803          //
    804          //*****************************************************************************
    805          void
    806          cfaf128x128x16Init(void){	
    807          	InitSSICom();
    808          	//ssiSetClockDivider(2);
    809          	//ssiSetDataMode(0);
    810          
    811          	SysCtlPeripheralEnable(DISPLAY_RST_GPIO_PERIPH);
    812          	SysCtlPeripheralEnable(DISPLAY_C_D_GPIO_PERIPH);
    813          	SysCtlPeripheralEnable(DISPLAY_CS_GPIO_PERIPH);
    814          	
    815          	//ROM_GPIOPinConfigure();
    816          		
    817          	// Configure display control pins as GPIO output
    818          	GPIOPinTypeGPIOOutput(DISPLAY_RST_PORT, DISPLAY_RST_PIN);
    819          	GPIOPinTypeGPIOOutput(DISPLAY_D_C_PORT, DISPLAY_D_C_PIN);
    820          	GPIOPinTypeGPIOOutput(DISPLAY_CS_PORT,  DISPLAY_CS_PIN);
    821          	
    822          	//-----------------
    823          	//Backlight configuration - lacking for now
    824          	//-----------------
    825          	
    826          	//Display reset
    827          	GPIOPinWrite(DISPLAY_RST_PORT, DISPLAY_RST_PIN, DISPLAY_RST_PIN);
    828          	delay(100);	
    829          	GPIOPinWrite(DISPLAY_RST_PORT, DISPLAY_RST_PIN, 0);
    830          	delay(50);
    831          	GPIOPinWrite(DISPLAY_RST_PORT, DISPLAY_RST_PIN, DISPLAY_RST_PIN);
    832          	delay(120);
    833          	
    834          	//Display initialization command set
    835          	cfaf128x128x16WriteCommand(CM_SWRESET);
    836          	delay(150);
    837          	cfaf128x128x16WriteCommand(CM_SLPOUT);
    838          	delay(200);
    839          	cfaf128x128x16WriteRegister(CM_GAMSET, 0x04);
    840          	cfaf128x128x16WriteCommand(CM_SETPWCTR);
    841          	cfaf128x128x16WriteData((const uint8_t*)"\x0A\x14", 2);
    842          	cfaf128x128x16WriteCommand(CM_SETSTBA);
    843          	cfaf128x128x16WriteData((const uint8_t*)"\x0A\x00", 2);
    844          	cfaf128x128x16WriteRegister(CM_COLMOD, 0x05);
    845          	delay(10);
    846          	cfaf128x128x16WriteRegister(CM_MADCTL, CM_MADCTL_RGB);
    847          	cfaf128x128x16WriteCommand(CM_CASET);
    848          	cfaf128x128x16WriteData((const uint8_t*)"\x00\x00\x00\x79", 4);
    849          	cfaf128x128x16WriteCommand(CM_RASET);
    850          	cfaf128x128x16WriteData((const uint8_t*)"\x00\x00\x00\x79", 4);
    851          	cfaf128x128x16WriteCommand(CM_NORON);
    852          	delay(10);
    853          	cfaf128x128x16WriteCommand(CM_DISPON);
    854          	
    855          	delay(120);
    856          	cfaf128x128x16WriteCommand(CM_RAMWR);
    857          	//Set backlight - if there's any
    858          	cfaf128x128x16SetOrientation(0);
    859          	cfaf128x128x16Clear();
    860          }
    861          
    862          //*****************************************************************************
    863          //
    864          // Close the Doxygen group.
    865          //! @}
    866          //
    867          //*****************************************************************************

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   InitSSICom
        24   -> GPIOPinConfigure
        24   -> GPIOPinTypeSSI
        24   -> SSIClockSourceSet
        24   -> SSIConfigSetExpClk
        24   -> SSIDataGetNonBlocking
        24   -> SSIEnable
        24   -> SysCtlPeripheralEnable
       8   cfaf128x128x16Clear
         8   -> cfaf128x128x16ClearColor
      16   cfaf128x128x16ClearColor
        16   -> cfaf128x128x16Rect
        16   -> cfaf128x128x16SetOrientation
       0   cfaf128x128x16ColorTranslate
      16   cfaf128x128x16Dot
        16   -> cfaf128x128x16Rect
       0   cfaf128x128x16Flush
       8   cfaf128x128x16Init
         8   -> GPIOPinTypeGPIOOutput
         8   -> GPIOPinWrite
         8   -> InitSSICom
         8   -> SysCtlDelay
         8   -> SysCtlPeripheralEnable
         8   -> cfaf128x128x16Clear
         8   -> cfaf128x128x16SetOrientation
         8   -> cfaf128x128x16WriteCommand
         8   -> cfaf128x128x16WriteData
         8   -> cfaf128x128x16WriteRegister
      24   cfaf128x128x16LineDrawH
        24   -> cfaf128x128x16LineHor
        24   -> swap_i32
      24   cfaf128x128x16LineDrawV
        24   -> cfaf128x128x16LineVer
        24   -> swap_i32
      16   cfaf128x128x16LineHor
        16   -> cfaf128x128x16Rect
      16   cfaf128x128x16LineVer
        16   -> cfaf128x128x16Rect
       8   cfaf128x128x16PixelDraw
         8   -> cfaf128x128x16Dot
      32   cfaf128x128x16PixelDrawMultiple
        32   -> GPIOPinWrite
        32   -> cfaf128x128x16SetWindow
        32   -> cfaf128x128x16SsiTransfer
      24   cfaf128x128x16Rect
        24   -> GPIOPinWrite
        24   -> cfaf128x128x16SetWindow
        24   -> cfaf128x128x16SsiTransfer
      24   cfaf128x128x16RectFill
        24   -> cfaf128x128x16Rect
        24   -> swap_ui16
      16   cfaf128x128x16SetOrientation
        16   -> cfaf128x128x16WriteCommand
        16   -> cfaf128x128x16WriteData
      32   cfaf128x128x16SetWindow
        32   -> cfaf128x128x16WriteCommand
        32   -> cfaf128x128x16WriteData
      16   cfaf128x128x16SsiTransfer
        16   -> SSIBusy
        16   -> SSIDataGet
        16   -> SSIDataPut
      16   cfaf128x128x16WriteCommand
        16   -> GPIOPinWrite
        16   -> cfaf128x128x16SsiTransfer
      16   cfaf128x128x16WriteData
        16   -> GPIOPinWrite
        16   -> cfaf128x128x16SsiTransfer
       8   cfaf128x128x16WriteRegister
         8   -> cfaf128x128x16WriteCommand
         8   -> cfaf128x128x16WriteData
       0   swap_i32
       0   swap_ui16


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ?_0
       4  ?_1
       8  ?_2
     108  InitSSICom
       1  _orientation
       2  blackColor
       2  blueColor
      12  cfaf128x128x16Clear
      40  cfaf128x128x16ClearColor
      26  cfaf128x128x16ColorTranslate
      28  cfaf128x128x16Dot
       2  cfaf128x128x16Flush
     264  cfaf128x128x16Init
      48  cfaf128x128x16LineDrawH
      48  cfaf128x128x16LineDrawV
      22  cfaf128x128x16LineHor
      30  cfaf128x128x16LineVer
      18  cfaf128x128x16PixelDraw
     432  cfaf128x128x16PixelDrawMultiple
     116  cfaf128x128x16Rect
      96  cfaf128x128x16RectFill
      82  cfaf128x128x16SetOrientation
     186  cfaf128x128x16SetWindow
      40  cfaf128x128x16SsiTransfer
      50  cfaf128x128x16WriteCommand
      62  cfaf128x128x16WriteData
      18  cfaf128x128x16WriteRegister
       2  cyanColor
       2  darkGrayColor
      40  g_sCfaf128x128x16
       4  g_ui32SysClock
       2  grayColor
       2  greenColor
       2  magentaColor
       2  orangeColor
       2  redColor
      10  swap_i32
      10  swap_ui16
       2  violetColor
       2  whiteColor
       2  yellowColor

 
     5 bytes in section .bss
    80 bytes in section .rodata
 1 836 bytes in section .text
 
 1 836 bytes of CODE  memory
    80 bytes of CONST memory
     5 bytes of DATA  memory

Errors: none
Warnings: 2
